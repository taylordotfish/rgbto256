/*
 * Copyright (C) 2021 taylor.fish <contact@taylor.fish>
 *
 * This file is part of rgbto256.
 *
 * rgbto256 is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published
 * by the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * rgbto256 is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with rgbto256. If not, see <https://www.gnu.org/licenses/>.
 */

#include "../color.h"
#include "../ecode.h"
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <libgen.h>
#include <string.h>
#include <stdbool.h>

#define FILENAME "ansidb.c"
#define ANSI_216_START 16
#define ANSI_GREY_START 232
#define ANSI_END 255

static const char * const file_parts[] = {
    "// This file was automatically generated by generate-ansidb.\n"
    "\n"
    "#include \"ansidb.h\"\n"
    "\n"
    "const RGBColor ansi_to_rgb_map[] = {\n",

    "};\n"
    "\n"
    "const LabColor ansi_to_lab_map[] = {\n",

    "};\n",
};

static inline size_t max_size(size_t a, size_t b) {
    return a > b ? a : b;
}

static inline int c216_val_to_rgb256(int val) {
    if (val == 0) {
        return 0;
    }
    return val * 40 + 55;
}

// 16 to 231
static RGBColor c216_to_rgb(int ansi_num) {
    int vals[3];
    int shifted = ansi_num - ANSI_216_START;
    for (size_t i = 0; i < 3; i++) {
        vals[i] = c216_val_to_rgb256(shifted % 6);
        shifted /= 6;
    }
    return rgb_from_ints(vals[2], vals[1], vals[0]);
}

// 232 to 255
static RGBColor cgrey_to_rgb(int ansi_num) {
    int shifted = ansi_num - ANSI_GREY_START;
    int val = shifted * 10 + 8;
    return rgb_from_ints(val, val, val);
}

static RGBColor ansi_to_rgb(int ansi_num) {
    if (ansi_num < ANSI_GREY_START) {
        return c216_to_rgb(ansi_num);
    }
    return cgrey_to_rgb(ansi_num);
}

static void write_rgb_color(FILE *file, int ansi_num) {
    RGBColor rgb = ansi_to_rgb(ansi_num);
    fprintf(file, "    { %a, %a, %a },\n", rgb.r, rgb.g, rgb.b);
}

static void write_rgb_colors(FILE *file) {
    for (int i = ANSI_216_START; i <= ANSI_END; i++) {
        write_rgb_color(file, i);
    }
}

static void write_lab_color(FILE *file, int ansi_num) {
    RGBColor rgb = ansi_to_rgb(ansi_num);
    LabColor lab = rgb_to_srgb_lab(rgb);
    fprintf(file, "    { %a, %a, %a },\n", lab.L, lab.a, lab.b);
}

static void write_lab_colors(FILE *file) {
    for (int i = ANSI_216_START; i <= ANSI_END; i++) {
        write_lab_color(file, i);
    }
}

static void (* const write_funcs[])(FILE *) = {
    NULL,
    write_rgb_colors,
    NULL,
    write_lab_colors,
    NULL,
};

static void write_all(FILE *file) {
    size_t file_part_i = 0;
    for (size_t i = 0; i < sizeof(write_funcs) / sizeof(*write_funcs); i++) {
        if (write_funcs[i] == NULL) {
            fputs(file_parts[file_part_i++], file);
        } else {
            write_funcs[i](file);
        }
    }
}

static bool open_and_write(const char *path) {
    FILE *file = fopen(path, "w");
    if (file == NULL) {
        return false;
    }
    write_all(file);
    fclose(file);
    return true;
}

static ExitCode open_and_write_or_ecode(const char *path) {
    if (!open_and_write(path)) {
        return exitcode_exit(1);
    }
    return exitcode_noexit;
}

static char *heap_dirname(const char *path) {
    size_t copy_len = max_size(strlen(path), 1);
    char *path_copy = malloc(copy_len + 1);
    if (path_copy == NULL) {
        return NULL;
    }

    const char *dir = dirname(path_copy);
    if (dir == path_copy) {
        return path_copy;
    }

    size_t dir_len = strlen(dir);
    if (strlen(dir) > copy_len) {
        if ((path_copy = realloc(path_copy, dir_len + 1)) == NULL) {
            return NULL;
        }
    }
    strcpy(path_copy, dir);
    return path_copy;
}

typedef enum {
    EPD_OK = 0,
    EPD_EMPTY_ARGV = 1,
    EPD_ALLOC_FAIL = 2,
    EPD_CHDIR_FAIL = 3,
} EPDStatus;

static EPDStatus enter_prog_dir(char **argv) {
    if (argv[0] == NULL) {
        return EPD_EMPTY_ARGV;
    }

    char *dir = heap_dirname(argv[0]);
    if (dir == NULL) {
        return EPD_ALLOC_FAIL;
    }

    int chdir_status = chdir(dir);
    free(dir);
    return chdir_status == 0 ? EPD_OK : EPD_CHDIR_FAIL;
}

static ExitCode enter_prog_dir_or_ecode(char **argv) {
    switch (enter_prog_dir(argv)) {
        case EPD_OK:
            return exitcode_noexit;

        case EPD_EMPTY_ARGV:
            fprintf(
                stderr, "Could not enter program directory (argv empty).\n"
            );
            break;

        case EPD_CHDIR_FAIL:
            fprintf(
                stderr, "Could not enter program directory (chdir() failed).\n"
            );
            break;

        case EPD_ALLOC_FAIL:
            fprintf(stderr, "Memory allocation failed.\n");
            break;

        default:
            fprintf(
                stderr, "Could not enter program directory (unknown error).\n"
            );
            break;
    }
    return exitcode_exit(1);
}

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wunused-parameter"
int main(int argc, char **argv) {
    maybe_exit(enter_prog_dir_or_ecode(argv));
    maybe_exit(open_and_write_or_ecode(FILENAME));
    return 0;
}
#pragma GCC diagnostic pop
